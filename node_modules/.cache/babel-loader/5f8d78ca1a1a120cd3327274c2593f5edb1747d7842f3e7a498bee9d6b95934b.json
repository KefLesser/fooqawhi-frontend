{"ast":null,"code":"import { placesData } from '../data/places.js';\nimport axios from 'axios';\nimport { API_CONFIG } from '../config/api.js';\n\n// Game state management\nclass GameService {\n  constructor() {\n    this.currentPlace = placesData.places[0]; // Use Matera for testing\n    this.guessResult = {};\n    this.geocodeResult = {};\n    this.currentHintIndex = 0;\n    this.hintsGiven = \"\";\n    this.guesses = [];\n    this.gameState = 'playing'; // 'playing', 'won', 'lost'\n    this.startTime = Date.now();\n    this.achievements = [];\n\n    // Google Geocoding API configuration\n    this.geocodingApiKey = API_CONFIG.GOOGLE_MAPS_API_KEY;\n    this.geocodingBaseUrl = API_CONFIG.GEOCODING_BASE_URL;\n  }\n\n  // Get current hint\n  getCurrentHint() {\n    let currentHint = null;\n    if (this.currentHintIndex < this.currentPlace.sarcastic_descriptions.length) {\n      currentHint = {\n        hintNumber: this.currentHintIndex + 1,\n        text: this.currentPlace.sarcastic_descriptions[this.currentHintIndex],\n        isLastHint: this.currentHintIndex === this.currentPlace.sarcastic_descriptions.length - 1\n      };\n      return currentHint;\n    }\n    return null;\n  }\n\n  // Get next hint\n  getNextHint() {\n    this.hintsGiven = this.hintsGiven + this.currentPlace.sarcastic_descriptions[this.currentHintIndex];\n\n    // .push({\n    //   id: this.currentHintIndex + 1, \n    //   text: this.currentPlace.sarcastic_descriptions[this.currentHintIndex] \n    // })\n    if (this.currentHintIndex < this.currentPlace.sarcastic_descriptions.length - 1) {\n      this.currentHintIndex++;\n      return this.getCurrentHint();\n    }\n    return null;\n  }\n\n  // Geocode a location using Google Geocoding API\n  async geocodeLocation(location, country) {\n    try {\n      const query = `${location}, ${country}`;\n      const response = await axios.get(this.geocodingBaseUrl, {\n        params: {\n          address: query,\n          key: this.geocodingApiKey\n        }\n      });\n      if (response.data.status === 'OK' && response.data.results.length > 0) {\n        const result = response.data.results[0];\n        const location = result.geometry.location;\n        return {\n          success: true,\n          latitude: location.lat,\n          longitude: location.lng,\n          formattedAddress: result.formatted_address,\n          placeId: result.place_id,\n          addressComponents: result.address_components\n        };\n      } else {\n        return {\n          success: false,\n          error: response.data.status || 'No results found'\n        };\n      }\n    } catch (error) {\n      console.error('Geocoding error:', error);\n      return {\n        success: false,\n        error: 'Geocoding service unavailable'\n      };\n    }\n  }\n\n  // Calculate distance between two points using Haversine formula\n  calculateDistance(lat1, lon1, lat2, lon2) {\n    const R = 6371; // Earth's radius in kilometers\n    const dLat = this.toRadians(lat2 - lat1);\n    const dLon = this.toRadians(lon2 - lon1);\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n  toRadians(degrees) {\n    return degrees * (Math.PI / 180);\n  }\n\n  // Calculate bearing between two points\n  calculateBearing(lat1, lon1, lat2, lon2) {\n    const dLon = this.toRadians(lon2 - lon1);\n    const lat1Rad = this.toRadians(lat1);\n    const lat2Rad = this.toRadians(lat2);\n    const y = Math.sin(dLon) * Math.cos(lat2Rad);\n    const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);\n    let bearing = Math.atan2(y, x);\n    bearing = (bearing * 180 / Math.PI + 360) % 360;\n    return bearing;\n\n    // const y = Math.sin(lon2-lon1) * Math.cos(lat2);\n    // const x = Math.cos(lat1)*Math.sin(lat2) -\n    //       Math.sin(lat1)*Math.cos(lat2)*Math.cos(lon2-lon1);\n    // const z = Math.atan2(y, x);\n    // const brng = (z*180/Math.PI + 360) % 360; // in degrees\n    // console.log({brng});\n    // return brng;\n  }\n\n  // Get direction from bearing\n  getDirection(bearing) {\n    console.log({\n      bearing\n    });\n    const directions = ['north', 'north-northeast', 'northeast', 'east-northeast', 'east', 'east-southeast', 'southeast', 'south-southeast', 'south', 'south-southwest', 'southwest', 'west-southwest', 'west', 'west-northwest', 'northwest', 'north-northwest'];\n    const index = Math.round(bearing / 22.5) % 16;\n    console.log({\n      index\n    });\n    console.log(directions[index]);\n    return directions[index];\n  }\n\n  // Check if guess is correct based on distance threshold\n  isGuessCorrect(guessLat, guessLon, targetLat, targetLon, thresholdKm = API_CONFIG.CORRECT_GUESS_THRESHOLD_KM) {\n    const distance = this.calculateDistance(guessLat, guessLon, targetLat, targetLon);\n    return distance <= thresholdKm;\n  }\n\n  // Submit a guess with geocoding validation\n  async submitGuess(guess) {\n    // First, geocode the guessed location\n    geocodeResult = await this.geocodeLocation(guess.location, guess.country);\n    if (!geocodeResult.success) {\n      return {\n        id: Date.now(),\n        location: guess.location,\n        country: guess.country,\n        timestamp: new Date(),\n        isCorrect: false,\n        error: geocodeResult.error,\n        distance: null,\n        geocodedLocation: null\n      };\n    }\n\n    // Calculate distance to target location\n    const distance = this.calculateDistance(geocodeResult.latitude, geocodeResult.longitude, this.currentPlace.latitude, this.currentPlace.longitude);\n\n    // Calculate bearing and direction\n    const bearing = this.calculateBearing(geocodeResult.latitude, geocodeResult.longitude, this.currentPlace.latitude, this.currentPlace.longitude);\n    const direction = this.getDirection(bearing);\n    console.log({\n      direction\n    });\n\n    // Check if guess is correct (within threshold)\n    const isCorrect = this.isGuessCorrect(geocodeResult.latitude, geocodeResult.longitude, this.currentPlace.latitude, this.currentPlace.longitude);\n    const guessData = {\n      id: Date.now(),\n      location: guess.location,\n      country: guess.country,\n      timestamp: new Date(),\n      isCorrect: isCorrect,\n      distance: Math.round(distance),\n      direction: direction,\n      bearing: Math.round(bearing),\n      geocodedLocation: {\n        latitude: geocodeResult.latitude,\n        longitude: geocodeResult.longitude,\n        formattedAddress: geocodeResult.formattedAddress\n      }\n    };\n    this.guessResult = guessData;\n    this.guesses.push(guessData);\n    if (guessData.isCorrect) {\n      this.gameState = 'won';\n      this.checkAchievements(); // Check achievements on win\n    } else if (this.guesses.length >= 5) {\n      this.gameState = 'lost';\n    }\n    return guessData;\n  }\n\n  // Get game status\n  getGameStatus() {\n    const gameTime = Date.now() - this.startTime;\n    const minutes = Math.floor(gameTime / 60000);\n    const seconds = Math.floor(gameTime % 60000 / 1000);\n    return {\n      currentHint: this.getCurrentHint(),\n      hintsGiven: this.hintsGiven,\n      hintsUsed: this.currentHintIndex + 1,\n      totalHints: this.currentPlace.sarcastic_descriptions.length,\n      guessesMade: this.guesses.length,\n      maxGuesses: 5,\n      gameState: this.gameState,\n      currentPlace: this.currentPlace,\n      guesses: this.guesses,\n      gameTime: `${minutes}:${seconds.toString().padStart(2, '0')}`,\n      achievements: this.achievements\n    };\n  }\n\n  // Check and award achievements\n  checkAchievements() {\n    const newAchievements = [];\n\n    // Speed achievements\n    const gameTime = Date.now() - this.startTime;\n    if (gameTime < 60000 && this.gameState === 'won') {\n      // Under 1 minute\n      newAchievements.push({\n        id: 'speed_demon',\n        title: 'Speed Demon',\n        description: 'Found the Fooqawhi in under 1 minute!',\n        icon: 'âš¡'\n      });\n    }\n\n    // Efficiency achievements\n    const hintEfficiency = (this.currentHintIndex + 1) / this.currentPlace.sarcastic_descriptions.length;\n    if (hintEfficiency <= 0.5 && this.gameState === 'won') {\n      // Used 50% or fewer hints\n      newAchievements.push({\n        id: 'hint_master',\n        title: 'Hint Master',\n        description: 'Solved with 50% or fewer hints!',\n        icon: 'ðŸ§ '\n      });\n    }\n\n    // Accuracy achievements\n    if (this.guesses.length === 1 && this.gameState === 'won') {\n      // First guess correct\n      newAchievements.push({\n        id: 'first_guess',\n        title: 'First Guess Wonder',\n        description: 'Found the Fooqawhi on your first try!',\n        icon: 'ðŸŽ¯'\n      });\n    }\n\n    // Add new achievements\n    newAchievements.forEach(achievement => {\n      if (!this.achievements.find(a => a.id === achievement.id)) {\n        this.achievements.push(achievement);\n      }\n    });\n    return newAchievements;\n  }\n\n  // Reset game\n  resetGame() {\n    this.currentHintIndex = 0;\n    this.hintsGiven = \"\";\n    this.guesses = [];\n    this.gameState = 'playing';\n    this.startTime = Date.now();\n    this.achievements = [];\n  }\n\n  // Get map center and zoom based on hint level\n  getMapView() {\n    var _this$guessResult, _this$guessResult2;\n    const baseZoom = 2;\n    const zoomIncrement = 1;\n    const currentZoom = Math.min(baseZoom + this.currentHintIndex * zoomIncrement, 8);\n    console.log(\"guessResult\", this.guessResult);\n    // const center = this.guessResult ? \n    //   [this.currentPlace.latitude, this.currentPlace.longitude]\n    return {\n      center: [((_this$guessResult = this.guessResult) === null || _this$guessResult === void 0 ? void 0 : _this$guessResult.geocodedLocation.latitude) | this.currentPlace.latitude, ((_this$guessResult2 = this.guessResult) === null || _this$guessResult2 === void 0 ? void 0 : _this$guessResult2.geocodedLocation.longitude) | this.currentPlace.longitude],\n      zoom: currentZoom\n    };\n  }\n\n  // Get feedback for incorrect guess\n  getGuessFeedback(guess) {\n    const distance = this.calculateDistance(guess);\n    const direction = this.getDirection(guess);\n    console.log({\n      distance,\n      direction\n    });\n    if (distance < 100) {\n      return \"You're very close! The Fooqawhi are practically within shouting distance.\";\n    } else if (distance < 500) {\n      return `You're getting warmer! The Fooqawhi are about ${Math.round(distance)}km ${direction} from your guess.`;\n    } else if (distance < 1000) {\n      return `Not quite there yet. The Fooqawhi are approximately ${Math.round(distance)}km ${direction} from your guess.`;\n    } else {\n      return `The Fooqawhi are quite far from your guess - about ${Math.round(distance)}km ${direction}.`;\n    }\n  }\n}\n\n// Create singleton instance\nconst gameService = new GameService();\nexport default gameService;","map":{"version":3,"names":["placesData","axios","API_CONFIG","GameService","constructor","currentPlace","places","guessResult","geocodeResult","currentHintIndex","hintsGiven","guesses","gameState","startTime","Date","now","achievements","geocodingApiKey","GOOGLE_MAPS_API_KEY","geocodingBaseUrl","GEOCODING_BASE_URL","getCurrentHint","currentHint","sarcastic_descriptions","length","hintNumber","text","isLastHint","getNextHint","geocodeLocation","location","country","query","response","get","params","address","key","data","status","results","result","geometry","success","latitude","lat","longitude","lng","formattedAddress","formatted_address","placeId","place_id","addressComponents","address_components","error","console","calculateDistance","lat1","lon1","lat2","lon2","R","dLat","toRadians","dLon","a","Math","sin","cos","c","atan2","sqrt","degrees","PI","calculateBearing","lat1Rad","lat2Rad","y","x","bearing","getDirection","log","directions","index","round","isGuessCorrect","guessLat","guessLon","targetLat","targetLon","thresholdKm","CORRECT_GUESS_THRESHOLD_KM","distance","submitGuess","guess","id","timestamp","isCorrect","geocodedLocation","direction","guessData","push","checkAchievements","getGameStatus","gameTime","minutes","floor","seconds","hintsUsed","totalHints","guessesMade","maxGuesses","toString","padStart","newAchievements","title","description","icon","hintEfficiency","forEach","achievement","find","resetGame","getMapView","_this$guessResult","_this$guessResult2","baseZoom","zoomIncrement","currentZoom","min","center","zoom","getGuessFeedback","gameService"],"sources":["/Users/keithlesser/Documents/projects/fooqawhi-frontend/src/services/gameService.js"],"sourcesContent":["import { placesData } from '../data/places.js';\nimport axios from 'axios';\nimport { API_CONFIG } from '../config/api.js';\n\n// Game state management\nclass GameService {\n  constructor() {\n    this.currentPlace = placesData.places[0]; // Use Matera for testing\n    this.guessResult = {};\n    this.geocodeResult = {};\n    this.currentHintIndex = 0;\n    this.hintsGiven = \"\";\n    this.guesses = [];\n    this.gameState = 'playing'; // 'playing', 'won', 'lost'\n    this.startTime = Date.now();\n    this.achievements = [];\n    \n    // Google Geocoding API configuration\n    this.geocodingApiKey = API_CONFIG.GOOGLE_MAPS_API_KEY;\n    this.geocodingBaseUrl = API_CONFIG.GEOCODING_BASE_URL;\n  }\n\n  // Get current hint\n  getCurrentHint() {\n    let currentHint = null;\n    if (this.currentHintIndex < this.currentPlace.sarcastic_descriptions.length) {\n      currentHint = {\n        hintNumber: this.currentHintIndex + 1,\n        text: this.currentPlace.sarcastic_descriptions[this.currentHintIndex],\n        isLastHint: this.currentHintIndex === this.currentPlace.sarcastic_descriptions.length - 1\n      };\n      return currentHint;\n    }\n    return null;\n  }\n\n  // Get next hint\n  getNextHint() {\n    this.hintsGiven = this.hintsGiven + this.currentPlace.sarcastic_descriptions[this.currentHintIndex]\n    \n    // .push({\n    //   id: this.currentHintIndex + 1, \n    //   text: this.currentPlace.sarcastic_descriptions[this.currentHintIndex] \n    // })\n    if (this.currentHintIndex < this.currentPlace.sarcastic_descriptions.length - 1) {\n      this.currentHintIndex++;\n      return this.getCurrentHint();\n    }\n    return null;\n  }\n\n  // Geocode a location using Google Geocoding API\n  async geocodeLocation(location, country) {\n    try {\n      const query = `${location}, ${country}`;\n      const response = await axios.get(this.geocodingBaseUrl, {\n        params: {\n          address: query,\n          key: this.geocodingApiKey\n        }\n      });\n\n      if (response.data.status === 'OK' && response.data.results.length > 0) {\n        const result = response.data.results[0];\n        const location = result.geometry.location;\n        \n        return {\n          success: true,\n          latitude: location.lat,\n          longitude: location.lng,\n          formattedAddress: result.formatted_address,\n          placeId: result.place_id,\n          addressComponents: result.address_components\n        };\n      } else {\n        return {\n          success: false,\n          error: response.data.status || 'No results found'\n        };\n      }\n    } catch (error) {\n      console.error('Geocoding error:', error);\n      return {\n        success: false,\n        error: 'Geocoding service unavailable'\n      };\n    }\n  }\n\n  // Calculate distance between two points using Haversine formula\n  calculateDistance(lat1, lon1, lat2, lon2) {\n    const R = 6371; // Earth's radius in kilometers\n    const dLat = this.toRadians(lat2 - lat1);\n    const dLon = this.toRadians(lon2 - lon1);\n    \n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n              Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) *\n              Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    \n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n\n  toRadians(degrees) {\n    return degrees * (Math.PI / 180);\n  }\n\n  // Calculate bearing between two points\n  calculateBearing(lat1, lon1, lat2, lon2) {\n    const dLon = this.toRadians(lon2 - lon1);\n    const lat1Rad = this.toRadians(lat1);\n    const lat2Rad = this.toRadians(lat2);\n    \n    const y = Math.sin(dLon) * Math.cos(lat2Rad);\n    const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - \n              Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);\n    \n    let bearing = Math.atan2(y, x);\n    bearing = (bearing * 180 / Math.PI + 360) % 360;\n    return bearing\n\n    // const y = Math.sin(lon2-lon1) * Math.cos(lat2);\n    // const x = Math.cos(lat1)*Math.sin(lat2) -\n    //       Math.sin(lat1)*Math.cos(lat2)*Math.cos(lon2-lon1);\n    // const z = Math.atan2(y, x);\n    // const brng = (z*180/Math.PI + 360) % 360; // in degrees\n    // console.log({brng});\n    // return brng;\n  }\n\n  // Get direction from bearing\n  getDirection(bearing) {\n    console.log({bearing});\n    const directions = [\n      'north', 'north-northeast', 'northeast', 'east-northeast',\n      'east', 'east-southeast', 'southeast', 'south-southeast',\n      'south', 'south-southwest', 'southwest', 'west-southwest',\n      'west', 'west-northwest', 'northwest', 'north-northwest'\n    ];\n    \n    const index = Math.round(bearing / 22.5) % 16;\n    console.log({index});\n    console.log(directions[index]);\n    return directions[index];\n  }\n\n  // Check if guess is correct based on distance threshold\n  isGuessCorrect(guessLat, guessLon, targetLat, targetLon, thresholdKm = API_CONFIG.CORRECT_GUESS_THRESHOLD_KM) {\n    const distance = this.calculateDistance(guessLat, guessLon, targetLat, targetLon);\n    return distance <= thresholdKm;\n  }\n\n  // Submit a guess with geocoding validation\n  async submitGuess(guess) {\n    // First, geocode the guessed location\n    geocodeResult = await this.geocodeLocation(guess.location, guess.country);\n    \n    if (!geocodeResult.success) {\n      return {\n        id: Date.now(),\n        location: guess.location,\n        country: guess.country,\n        timestamp: new Date(),\n        isCorrect: false,\n        error: geocodeResult.error,\n        distance: null,\n        geocodedLocation: null\n      };\n    }\n\n    // Calculate distance to target location\n    const distance = this.calculateDistance(\n      geocodeResult.latitude,\n      geocodeResult.longitude,\n      this.currentPlace.latitude,\n      this.currentPlace.longitude\n    );\n\n    // Calculate bearing and direction\n    const bearing = this.calculateBearing(\n      geocodeResult.latitude,\n      geocodeResult.longitude,\n      this.currentPlace.latitude,\n      this.currentPlace.longitude\n    );\n    const direction = this.getDirection(bearing);\n    console.log({direction});\n\n    // Check if guess is correct (within threshold)\n    const isCorrect = this.isGuessCorrect(\n      geocodeResult.latitude,\n      geocodeResult.longitude,\n      this.currentPlace.latitude,\n      this.currentPlace.longitude\n    );\n\n    const guessData = {\n      id: Date.now(),\n      location: guess.location,\n      country: guess.country,\n      timestamp: new Date(),\n      isCorrect: isCorrect,\n      distance: Math.round(distance),\n      direction: direction,\n      bearing: Math.round(bearing),\n      geocodedLocation: {\n        latitude: geocodeResult.latitude,\n        longitude: geocodeResult.longitude,\n        formattedAddress: geocodeResult.formattedAddress\n      }\n    };\n    this.guessResult = guessData;\n\n    this.guesses.push(guessData);\n\n    if (guessData.isCorrect) {\n      this.gameState = 'won';\n      this.checkAchievements(); // Check achievements on win\n    } else if (this.guesses.length >= 5) {\n      this.gameState = 'lost';\n    }\n\n    return guessData;\n  }\n\n  // Get game status\n  getGameStatus() {\n    const gameTime = Date.now() - this.startTime;\n    const minutes = Math.floor(gameTime / 60000);\n    const seconds = Math.floor((gameTime % 60000) / 1000);\n    \n    return {\n      currentHint: this.getCurrentHint(),\n      hintsGiven: this.hintsGiven,\n      hintsUsed: this.currentHintIndex + 1,\n      totalHints: this.currentPlace.sarcastic_descriptions.length,\n      guessesMade: this.guesses.length,\n      maxGuesses: 5,\n      gameState: this.gameState,\n      currentPlace: this.currentPlace,\n      guesses: this.guesses,\n      gameTime: `${minutes}:${seconds.toString().padStart(2, '0')}`,\n      achievements: this.achievements\n    };\n  }\n\n  // Check and award achievements\n  checkAchievements() {\n    const newAchievements = [];\n    \n    // Speed achievements\n    const gameTime = Date.now() - this.startTime;\n    if (gameTime < 60000 && this.gameState === 'won') { // Under 1 minute\n      newAchievements.push({\n        id: 'speed_demon',\n        title: 'Speed Demon',\n        description: 'Found the Fooqawhi in under 1 minute!',\n        icon: 'âš¡'\n      });\n    }\n    \n    // Efficiency achievements\n    const hintEfficiency = (this.currentHintIndex + 1) / this.currentPlace.sarcastic_descriptions.length;\n    if (hintEfficiency <= 0.5 && this.gameState === 'won') { // Used 50% or fewer hints\n      newAchievements.push({\n        id: 'hint_master',\n        title: 'Hint Master',\n        description: 'Solved with 50% or fewer hints!',\n        icon: 'ðŸ§ '\n      });\n    }\n    \n    // Accuracy achievements\n    if (this.guesses.length === 1 && this.gameState === 'won') { // First guess correct\n      newAchievements.push({\n        id: 'first_guess',\n        title: 'First Guess Wonder',\n        description: 'Found the Fooqawhi on your first try!',\n        icon: 'ðŸŽ¯'\n      });\n    }\n    \n    // Add new achievements\n    newAchievements.forEach(achievement => {\n      if (!this.achievements.find(a => a.id === achievement.id)) {\n        this.achievements.push(achievement);\n      }\n    });\n    \n    return newAchievements;\n  }\n\n  // Reset game\n  resetGame() {\n    this.currentHintIndex = 0;\n    this.hintsGiven = \"\";\n    this.guesses = [];\n    this.gameState = 'playing';\n    this.startTime = Date.now();\n    this.achievements = [];\n  }\n\n  // Get map center and zoom based on hint level\n  getMapView() {\n    const baseZoom = 2;\n    const zoomIncrement = 1;\n    const currentZoom = Math.min(baseZoom + (this.currentHintIndex * zoomIncrement), 8);\n    console.log(\"guessResult\", this.guessResult)\n    // const center = this.guessResult ? \n    //   [this.currentPlace.latitude, this.currentPlace.longitude]\n    return {\n      center:[this.guessResult?.geocodedLocation.latitude | this.currentPlace.latitude, this.guessResult?.geocodedLocation.longitude | this.currentPlace.longitude],\n      zoom: currentZoom\n    };\n  }\n\n  // Get feedback for incorrect guess\n  getGuessFeedback(guess) {\n    const distance = this.calculateDistance(guess);\n    const direction = this.getDirection(guess);\n    console.log({distance, direction});\n    \n    if (distance < 100) {\n      return \"You're very close! The Fooqawhi are practically within shouting distance.\";\n    } else if (distance < 500) {\n      return `You're getting warmer! The Fooqawhi are about ${Math.round(distance)}km ${direction} from your guess.`;\n    } else if (distance < 1000) {\n      return `Not quite there yet. The Fooqawhi are approximately ${Math.round(distance)}km ${direction} from your guess.`;\n    } else {\n      return `The Fooqawhi are quite far from your guess - about ${Math.round(distance)}km ${direction}.`;\n    }\n  }\n}\n\n// Create singleton instance\nconst gameService = new GameService();\n\nexport default gameService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}